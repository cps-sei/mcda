// asynchronous collision avoidance protocol
MOC_ASYNC;

TARGET GNU_CPP,WIN_CPP %%{
#define GNU_WIN
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <boost/lexical_cast.hpp>
#include "madara/utility/Utility.h"

const double MOVE_TO_PROB = 0.6;

int flip (double prob)
{
  return rand() < (RAND_MAX * prob);
}

int rand_wrapper ()
{
  return rand();
}

int MOVE_TO (int x, int y)
{
  return flip(MOVE_TO_PROB);
}

// Intersection bounds
std::vector<int> x_lower_bounds = {2, 8, 14};
std::vector<int> x_upper_bounds = {3, 9, 15};
std::vector<int> y_lower_bounds = {2, 8};
std::vector<int> y_upper_bounds = {3, 9};

bool is_on_lane (int x, int y)
{
  for (int i = 0; i < NUM_INTS_X; i++)
  {
    if (x >= x_lower_bounds[i] && x <= x_upper_bounds[i])
    {
      return true;
    }
  }

  for (int i = 0; i < NUM_INTS_Y; i++)
  {
    if (y >= y_lower_bounds[i] && y <= y_upper_bounds[i])
    {
      return true;
    }
  }

  return false;
}

void print_line(int _X)
{
  printf("-");
  for(int i = 0;i < _X;++i) printf("---");
  printf("\n");
}

void print_global_state ()
{
  int my_id = (int) *id;
  int my_state = (int) state[*id];
  int round = (int) *round_count;

  for (int i = 0; i < 150; ++i)
    printf("\n");

  printf("round = %d : id = %d : state = %d\n", round, my_id, my_state);
  printf("_X = %d : _Y = %d\n", X, Y);
  print_line(X);

  for (int j = 0; j < Y; ++j) {
    for (int i = 0; i < X; ++i) {
      if (!is_on_lane(i, j) && !is_on_lane(i + 1, j)) {
        printf("   ");
        continue;
      } else if (!is_on_lane(i, j) && is_on_lane(i + 1, j)) {
        printf("  |");
        continue;
      }

      bool taken = false;

      if (i == x[my_id] && j == y[my_id]) {
        // Location of this node is always visible
        printf("%d*|", my_id);
        continue;
      }

      for (int k = 0; k < processes; ++k) {
        if (k == my_id) {
          continue;
        }

        if (i == true_x[k] && j == true_y[k]) {
          // True locations of other nodes
          printf("%d'|", k);
          taken = true;
          break;
        }

        if (i == x[k] && j == y[k]) {
          // Locations of other nodes from this node's perception
          printf("%d |", k);
          taken = true;
          break;
        }
      }

      if (!taken) {
        printf("  |");
      }
    }
    printf("\n");
    print_line(X);
  }
}

const int k = 0.01;
const int M = 500;
const int MPU = 3.7; // Meters per unit length

// Drop simulation function must have this signature
// MADARA-specific
bool prob_distance_drop (Madara::Knowledge_Map & incoming_records,
                         const Madara::Transport::Transport_Context & context,
                         Madara::Knowledge_Engine::Variables & vars)
{
  Integer sid = incoming_records["id"].to_integer();
  std::string sender_id = boost::lexical_cast<std::string>(sid);
  Integer dx = x[*id] - incoming_records["x." + sender_id].to_integer();
  Integer dy = y[*id] - incoming_records["y." + sender_id].to_integer();
  double dr = sqrt(dx * dx + dy * dy);
  double d = dr * MPU;
  double drop_prob = 1 - (1 / (1 + exp(-2 * k * (-d + M))));
  return rand() < (RAND_MAX * drop_prob);
}

//do some basic initialization at the start of the node
void basic_node_init()
{
  srand(getpid());
}
%%}

//directives
@SEND_HEARTBEATS;
@DROP_SIMULATION(prob_distance_drop);
@PERIODIC(2000);

// Grid size
CONST X = 18;
CONST Y = 12;

// Number of intersections
// in each axis
CONST NUM_INTS_X = 3;
CONST NUM_INTS_Y = 2;

CONST N = 0;
CONST E = 1;
CONST W = 2;
CONST S = 3;

// Number of lanes
// in each direction
CONST NUM_N_LANES = 3;
CONST NUM_E_LANES = 2;
CONST NUM_W_LANES = 2;
CONST NUM_S_LANES = 3;

// Lanes moving N
CONST Ax = 3;
CONST Bx = 9;
CONST Cx = 15;
// Lanes moving E
CONST Dy = 2;
CONST Ey = 8;
// Lanes moving W
CONST Fy = 3;
CONST Gy = 9;
// Lanes moving S
CONST Hx = 2;
CONST Ix = 8;
CONST Jx = 14;

// Node states
CONST INITS = 0;
CONST OUTSIDE = 1;
CONST APPROACH = 2;
CONST CROSS = 3;
CONST FAR = 4;

// Intersection protocol
CONST TCL_LENGTH = 5;

EXTERN int MOVE_TO (int x, int y);
EXTERN int flip (double prob);
EXTERN int rand_wrapper ();
EXTERN void print_global_state();
EXTERN void basic_node_init();

NODE uav (id)
{
  // CONSTANTS

  // Intersection boundaries
  LOCAL int X_LOWER_BOUNDS [NUM_INTS_X];
  LOCAL int X_UPPER_BOUNDS [NUM_INTS_X];
  LOCAL int Y_LOWER_BOUNDS [NUM_INTS_Y];
  LOCAL int Y_UPPER_BOUNDS [NUM_INTS_Y];

  // N/E/W/S lanes
  LOCAL int N_lanes [NUM_N_LANES];
  LOCAL int E_lanes [NUM_E_LANES];
  LOCAL int W_lanes [NUM_W_LANES];
  LOCAL int S_lanes [NUM_S_LANES];

  // END CONSTANTS

  // State of each node
  TRACK GLOBAL int state [#N];

  // Current x-y coordinates of each node
  TRACK GLOBAL int x [#N];
  TRACK GLOBAL int y [#N];

  // Trajectory Cells List (TCL) of each node
  // 1st element is current location
  GLOBAL int x_TCL [TCL_LENGTH][#N];
  GLOBAL int y_TCL [TCL_LENGTH][#N];

  // Trajectory Intersecting Cells (TIC)
  // Each element indicates whether the corresponding (same index)
  // element in TCL is a TIC
  LOCAL _Bool TIC [TCL_LENGTH];

  // Trajectory Intersecting Node
  // -1 means no intersecting node
  LOCAL int TIN [TCL_LENGTH];

  LOCAL int next_x;
  LOCAL int next_y;

  void NODE_INIT () {
    int i, j; // for-loop variables

    // do basic initialization
    basic_node_init();

    RESET_TCL();

    // Define intersection boundaries
    X_LOWER_BOUNDS[0] = Hx;
    X_UPPER_BOUNDS[0] = Ax;
    X_LOWER_BOUNDS[1] = Ix;
    X_UPPER_BOUNDS[1] = Bx;
    X_LOWER_BOUNDS[2] = Jx;
    X_UPPER_BOUNDS[2] = Cx;
    Y_LOWER_BOUNDS[0] = Dy;
    Y_UPPER_BOUNDS[0] = Fy;
    Y_LOWER_BOUNDS[1] = Ey;
    Y_UPPER_BOUNDS[1] = Gy;

    // Define N lanes
    N_lanes[0] = Ax;
    N_lanes[1] = Bx;
    N_lanes[2] = Cx;

    // Define E lanes
    E_lanes[0] = Dy;
    E_lanes[1] = Ey;

    // Define W lanes
    W_lanes[0] = Fy;
    W_lanes[1] = Gy;

    // Define S lanes
    S_lanes[0] = Hx;
    S_lanes[1] = Ix;
    S_lanes[2] = Jx;
  }

  // Get current lane
  // Only called in states OUTSIDE and APPROACH
  int ON_LANE () {
    int i;
    for (i = 0; i < NUM_N_LANES; i = i + 1) {
      if (x[id] == N_lanes[i]) {
        return N;
      }
    }
    for (i = 0; i < NUM_E_LANES; i = i + 1) {
      if (y[id] == E_lanes[i]) {
        return E;
      }
    }
    for (i = 0; i < NUM_W_LANES; i = i + 1) {
      if (y[id] == W_lanes[i]) {
        return W;
      }
    }
    for (i = 0; i < NUM_S_LANES; i = i + 1) {
      if (x[id] == S_lanes[i]) {
        return S;
      }
    }
    // should never get here
    return -1;
  }

  // Get next_x, next_y
  // Only called in state OUTSIDE
  void NEXT_XY () {
    int lane;
    lane = ON_LANE();

    if (lane == N) {
      next_x = x[id];
      next_y = y[id] + 1;
    } else if (lane == E) {
      next_x = x[id] + 1;
      next_y = y[id];
    } else if (lane == W) {
      next_x = x[id] - 1;
      next_y = y[id];
    } else if (lane == S) {
      next_x = x[id];
      next_y = y[id] - 1;
    }
  }

  // Reset TCL, TIC, TIN
  void RESET_TCL () {
    int i;
    for (i = 0; i < TCL_LENGTH; i = i + 1) {
      x_TCL[i][id] = -1;
      y_TCL[i][id] = -1;
      TIC[i] = 0;
      TIN[i] = -1;
    }
  }

  // Compute TCL
  // Only called in state APPROACH
  void COMPUTE_TCL () {
    int lane, r;

    // Fill in 1st element in TCL (current x,y)
    x_TCL[0][id] = x[id];
    y_TCL[0][id] = y[id];

    // Fill in the rest of TCL
    lane = ON_LANE(x[id], y[id]);
    r = rand_wrapper() % 3;

    if (r == 0) {
      // Go straight
      if (lane == N) {
        x_TCL[1][id] = x[id];
        y_TCL[1][id] = y[id] + 1;
        x_TCL[2][id] = x[id];
        y_TCL[2][id] = y[id] + 2;
        x_TCL[3][id] = x[id];
        y_TCL[3][id] = y[id] + 3;
      } else if (lane == E) {
        x_TCL[1][id] = x[id] + 1;
        y_TCL[1][id] = y[id];
        x_TCL[2][id] = x[id] + 2;
        y_TCL[2][id] = y[id];
        x_TCL[3][id] = x[id] + 3;
        y_TCL[3][id] = y[id];
      } else if (lane == W) {
        x_TCL[1][id] = x[id] - 1;
        y_TCL[1][id] = y[id];
        x_TCL[2][id] = x[id] - 2;
        y_TCL[2][id] = y[id];
        x_TCL[3][id] = x[id] - 3;
        y_TCL[3][id] = y[id];
      } else if (lane == S) {
        x_TCL[1][id] = x[id];
        y_TCL[1][id] = y[id] - 1;
        x_TCL[2][id] = x[id];
        y_TCL[2][id] = y[id] - 2;
        x_TCL[3][id] = x[id];
        y_TCL[3][id] = y[id] - 3;
      }
    } else if (r == 1) {
      // Turn left
      if (lane == N) {
        x_TCL[1][id] = x[id];
        y_TCL[1][id] = y[id] + 1;
        x_TCL[2][id] = x[id];
        y_TCL[2][id] = y[id] + 2;
        x_TCL[3][id] = x[id] - 1;
        y_TCL[3][id] = y[id] + 2;
        x_TCL[3][id] = x[id] - 2;
        y_TCL[3][id] = y[id] + 2;
      } else if (lane == E) {
        x_TCL[1][id] = x[id] + 1;
        y_TCL[1][id] = y[id];
        x_TCL[2][id] = x[id] + 2;
        y_TCL[2][id] = y[id];
        x_TCL[3][id] = x[id] + 2;
        y_TCL[3][id] = y[id] + 1;
        x_TCL[3][id] = x[id] + 2;
        y_TCL[3][id] = y[id] + 2;
      } else if (lane == W) {
        x_TCL[1][id] = x[id] - 1;
        y_TCL[1][id] = y[id];
        x_TCL[2][id] = x[id] - 2;
        y_TCL[2][id] = y[id];
        x_TCL[3][id] = x[id] - 2;
        y_TCL[3][id] = y[id] - 1;
        x_TCL[3][id] = x[id] - 2;
        y_TCL[3][id] = y[id] - 2;
      }
    } else {
      // Turn right
      if (lane == N) {
        x_TCL[1][id] = x[id];
        y_TCL[1][id] = y[id] + 1;
        x_TCL[2][id] = x[id] + 1;
        y_TCL[2][id] = y[id] + 1;
      } else if (lane == E) {
        x_TCL[1][id] = x[id] + 1;
        y_TCL[1][id] = y[id];
        x_TCL[2][id] = x[id] + 1;
        y_TCL[2][id] = y[id] - 1;
      } else if (lane == W) {
        x_TCL[1][id] = x[id] - 1;
        y_TCL[1][id] = y[id];
        x_TCL[2][id] = x[id] - 1;
        y_TCL[2][id] = y[id] + 1;
      } else if (lane == S) {
        x_TCL[1][id] = x[id];
        y_TCL[1][id] = y[id] - 1;
        x_TCL[2][id] = x[id] - 1;
        y_TCL[2][id] = y[id] - 1;
      }
    }
  }

  int CDAI (int other) {
    int i, j; // for-loop variables

    for (i = 0; i < TCL_LENGTH; i = i + 1) {
      for (j = 0; j < TCL_LENGTH; j = j + 1) {
        if (x_TCL[i][id] != -1 // -1 means no element at i in TCL
            && x_TCL[i][id] == x_TCL[j][other]
            && y_TCL[i][id] == y_TCL[j][other]) {
          // Index of the TIC in this node's TCL
          return i;
        }
      }
    }
    // No TIC
    return -1;
  }

  // Check if xp, yp is inside intersection
  int IN_INT (int xp, int yp) {
    int i, j;
    for (i = 0; i < NUM_INTS_X; i = i + 1) {
      for (j = 0; j < NUM_INTS_Y; j = j + 1) {
        if (xp >= X_LOWER_BOUNDS[i] && xp <= X_UPPER_BOUNDS[i] &&
            yp >= Y_LOWER_BOUNDS[j] && yp <= Y_UPPER_BOUNDS[j]) {
          // Inside intersection
          return 1;
        }
      }
    }
    return 0;
  }

  void ROUND () {
    int TIC_index;
    int int_node; // intersecting node
    int i, j; // for-loop variable
    int res;

    print_global_state();

    if (state[id] == INITS) {
      // Assume valid initial location,
      // i.e., on a lane and not approaching or crossing intersection

      state[id] = OUTSIDE;
    }

    if (state[id] == OUTSIDE) {
      if (x[id] < 0 || x[id] >= X || y[id] < 0 || y[id] >= Y) {
        // Out of grid bound
        state[id] = FAR;
        done[id] = 1; // this node is done and ready to terminate
        return;
      }

      // Get next point
      NEXT_XY();

      if (!EXISTS_ANY (n, x[n] == next_x && y[n] == next_y)) {
        // Next point is unoccupied

        if (MOVE_TO(next_x, next_y)) {
          // Move to next point
          x[id] = next_x;
          y[id] = next_y;

          // Check if approaching intersection,
          // i.e., if next point is inside intersection
          NEXT_XY();
          res = IN_INT (next_x, next_y);

          if (res == 1) {
            // Approaching intersection
            state[id] = APPROACH;
            COMPUTE_TCL(); //-- so that TCL gets broadcasted before next round
          }
        }
      }
    } else if (state[id] == APPROACH) {
      // Priority policy:
      // 1. Crossing nodes > approaching nodes (FCFS)
      // 2. Higher-id nodes > lower-id nodes

      FORALL_OTHER (n) {
        if ((state[n] == CROSS) || (state[n] == APPROACH && n > id)) {
          // Node n has higher priority
          // Get index of TIC in this node's TCL, if exists
          TIC_index = CDAI(n);

          if (TIC_index >= 0) {
            // TIC exists
            // Keep track of all TICs and corresponding nodes
            TIC[TIC_index] = 1;
            TIN[TIC_index] = n;
          }
        }
        // Not keep track of TICs of lower-priority nodes
      }

      state[id] = CROSS;
    } else if (state[id] == CROSS) {
      // Get next point in TCL
      next_x = x_TCL[1][id];
      next_y = y_TCL[1][id];

      if (TIC[1] == 1) {
        // Next cell is TIC
        int_node = TIN[1];

        for (i = 0; i < TCL_LENGTH; i = i + 1) {
          if (x_TCL[i][int_node] == next_x && y_TCL[i][int_node] == next_y) {
            // The (higher-priority) intersecting node has not gone pass the TIC yet
            // Must wait
            return;
          }
        }
      }

      if (MOVE_TO(next_x, next_y)) {
        // Move to next point
        x[id] = next_x;
        y[id] = next_y;

        // Check if exiting intersection
        res = IN_INT (x[id], y[id]);
        if (res == 0) {
          // Exiting intersection
          state[id] = OUTSIDE;
          RESET_TCL(); //-- so that TCL gets broadcasted before next round
        }
      }
    }
  }

  // BELOW FUNCTIONS ARE CALLED BEFORE EACH ROUND
  // IN THE ORDER THEY APPEAR

  @ONCE_EVERY (10)
  void LOG_STATUS () {
    LOG(state[id], x[id], y[id]);
  }

  // Check safety property
  // Terminate this node if property is violated
  // IMP0RTANT NOTE:
  // Once any node terminated, the master process must kill all other nodes.
  @ONCE_EVERY (1)
  void NODE_ASSERT () {
    FORALL_OTHER (i) {
      if (true_state[i] != FAR) { // Not consider nodes that are out of grid boundary
        // Assert no collision
        LOCAL_ASSERT (true_x[i] != x[id] || true_y[i] != y[id]);
      }
    }
  }

  // Check if all nodes are done, i.e., state == FAR,
  // if so, terminate this node
  // IMPORTANT NOTE:
  // If this node terminates before it successfully broadcasts its "done" flag,
  // other nodes will continue indefinitely.
  // To handle this, have the master process kill all other nodes if any node terminated.
  @ONCE_EVERY (1)
  void CHECK_ALL_DONE () {
    if (!EXISTS_ANY (i, done[i] == 0)) {
      // Terminate this node
      EXIT;
    }
  }

}

//program has four nodes with ids 0, 1, 2, and 3
PROGRAM = uav (0) || uav (1) || uav (2) || uav (3);

//initial state
void INIT () 
{
  ATOMIC {
    FORALL_NODE(id) {
      state.id = INITS;
      ND(x.id); ND(y.id);
      ASSUME(0 <= x.id && x.id < X && 0 <= y.id && y.id < Y);
      ND(xf.id); ND(yf.id);
      ASSUME(0 <= xf.id && xf.id < X && 0 <= yf.id && yf.id < Y);
    }
  }

  FORALL_DISTINCT_NODE_PAIR (id1,id2) {
    ASSUME(x.id1 != x.id2 || y.id1 != y.id2);
  }
}

//the safety property checked at the beginning of each round
void SAFETY ()
{
  FORALL_DISTINCT_NODE_PAIR (id1,id2) {
    ASSERT(x.id1 != x.id2 || y.id1 != y.id2);
  }
}
