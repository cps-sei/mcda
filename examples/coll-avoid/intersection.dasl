// asynchronous collision avoidance protocol
MOC_ASYNC;

TARGET GNU_CPP,WIN_CPP %%{
#define GNU_WIN
#include <stdlib.h>
#include <math.h>
#include <unistd.h>
#include <boost/lexical_cast.hpp>
#include "madara/utility/Utility.h"

const double MOVE_TO_PROB = 0.6;

int flip (double prob)
{
  return rand() < (RAND_MAX * prob);
}

int MOVE_TO (int x, int y)
{
  return flip(MOVE_TO_PROB);
}

void print_line(int _X)
{
  printf("-");
  for(int i = 0;i < _X;++i) printf("---");
  printf("\n");
}

void print_global_state ()
{
  int my_id = (int) *id;
  int my_state = (int) state[*id];
  int round = (int) *round_count;

  for (int i = 0; i < 150; ++i)
    printf("\n");

  printf("round = %d : id = %d : state = %d\n", round, my_id, my_state);
  printf("_X = %d : _Y = %d\n", X, Y);
  print_line(X);

  for (int j = 0; j < Y; ++j) {
    printf("|");

    for (int i = 0; i < X; ++i) {
      bool taken = false;

      if (i == x[my_id] && j == y[my_id]) {
        // Location of this node is always visible
        printf("%d*|", my_id);
        continue;
      }

      for (int k = 0; k < processes; ++k) {
        if (k == my_id) {
          continue;
        }

        if (i == true_x[k] && j == true_y[k]) {
          // True locations of other nodes
          printf("%d'|", k);
          taken = true;
          break;
        }

        if (i == x[k] && j == y[k]) {
          // Locations of other nodes from this node's perception
          printf("%d |", k);
          taken = true;
          break;
        }
      }

      if (!taken) {
        printf("  |");
      }
    }
    printf("\n");
    print_line(X);
  }
}

// Drop simulation function must have this signature
// MADARA-specific
bool prob_distance_drop (Madara::Knowledge_Map & incoming_records,
                         const Madara::Transport::Transport_Context & context,
                         Madara::Knowledge_Engine::Variables & vars)
{
  // TODO
  return false;
}

//do some basic initialization at the start of the node
void basic_node_init()
{
  srand(getpid());
}
%%}

//directives
@SEND_HEARTBEATS;
@DROP_SIMULATION(prob_distance_drop);
@PERIODIC(2000);

// Grid size
CONST X = 6;
CONST Y = 6;

// Number of intersections
// in each axis
CONST NUM_INTS_X = 1;
CONST NUM_INTS_Y = 1;

// Lanes moving N
CONST Ax = 3;
// Lanes moving E
CONST By = 2;
// Lanes moving W
CONST Cy = 3;
// Lanes moving S
CONST Dx = 2;

// Node states
CONST INITS = 0;
CONST OUTSIDE = 1;
CONST APPROACH = 2;
CONST CROSS = 3;
CONST FAR = 4;

// Intersection protocol
CONST TCL_LENGTH = 5;

EXTERN int MOVE_TO (int x, int y);
EXTERN int flip (double prob);
EXTERN void print_global_state();
EXTERN void basic_node_init();

NODE uav (id)
{
  // CONSTANTS

  // N/E/W/S lanes
  LOCAL int N_lanes [NUM_INTS_X];
  LOCAL int E_lanes [NUM_INTS_Y];
  LOCAL int W_lanes [NUM_INTS_Y];
  LOCAL int S_lanes [NUM_INTS_X];

  // Direction vector field
  LOCAL _Bool v_field_N [X][Y][#N];
  LOCAL _Bool v_field_E [X][Y][#N];
  LOCAL _Bool v_field_W [X][Y][#N];
  LOCAL _Bool v_field_S [X][Y][#N];

  // END CONSTANTS

  // State of each node
  TRACK GLOBAL int state [#N];

  // Current x-y coordinates of each node
  TRACK GLOBAL int x [#N];
  TRACK GLOBAL int y [#N];

  // Trajectory Cells List (TCL) of each node
  // 1st element is current location
  GLOBAL int x_TCL [TCL_LENGTH][#N];
  GLOBAL int y_TCL [TCL_LENGTH][#N];

  // Trajectory Intersecting Cells (TIC)
  // Each element indicates whether the corresponding (same index)
  // element in TCL is a TIC
  LOCAL _Bool TIC [TCL_LENGTH];

  // Trajectory Intersecting Node
  // -1 means no intersecting node
  LOCAL int TIN [TCL_LENGTH];

  void NODE_INIT () {
    int i, j; // for-loop variables

    // do basic initialization
    basic_node_init();

    // Initialize TIN
    for (i = 0; i < TCL_LENGTH; i = i + 1) {
      // No intersecting node
      TIN[i] = -1;
    }

    // Define all lanes
    N_lanes[0] = Ax;
    E_lanes[0] = By;
    W_lanes[0] = Cy;
    S_lanes[0] = Dx;

    // Create vector field
    for (i = 0; i < NUM_INTS_X; i = i + 1) {
      // N & S
      for (j = 0; j < Y; j = j + 1) {
        v_field_N [N_lanes[i]][j] = 1;
        v_field_S [S_lanes[i]][j] = 1;
      }
    }

    for (i = 0; i < NUM_INTS_Y; i = i + 1) {
      // E & W
      for (j = 0; j < X; j = j + 1) {
        v_field_E [j][E_lanes[i]] = 1;
        v_field_W [j][W_lanes[i]] = 1;
      }
    }
  }

  void COMPUTE_TCL () {
    int i; // for-loop variable

    // Fill in 1st element in TCL (current x,y)
    x_TCL[0][id] = x[id];
    y_TCL[0][id] = y[id];

    // Fill in the rest of TCL
    for (i = 1; i < TCL_LENGTH; i = i + 1) {
      NEXT_XY(i);
    }
  }

  void UPDATE_TCL () {
    int i; // for-loop variable

    // Shift current elements in TCL to the left
    for (i = 0; i < TCL_LENGTH - 1; i = i + 1) {
      x_TCL[i][id] = x_TCL[i + 1][id];
      y_TCL[i][id] = y_TCL[i + 1][id];
    }

    NEXT_XY(TCL_LENGTH - 1);
  }

  void NEXT_XY (int TCL_index) {
    int cur_x, cur_y, next_x, next_y;
    int b;

    cur_x = x_TCL[TCL_index - 1][id];
    cur_y = y_TCL[TCL_index - 1][id];

    // Choose next legal point (randomly if 2 choices)
    b = flip(0.5);

    if (v_field_N [cur_x][cur_y] == 1 && v_field_E [cur_x][cur_y] == 1) {
      // Go N or E
      if (b) {
        next_x = cur_x;
        next_y = cur_y + 1;
      } else {
        next_x = cur_x + 1;
        next_y = cur_y;
      }
    } else if (v_field_N [cur_x][cur_y] == 1 && v_field_W [cur_x][cur_y] == 1) {
      // Go N or W
      if (b) {
        next_x = cur_x;
        next_y = cur_y + 1;
      } else {
        next_x = cur_x - 1;
        next_y = cur_y;
      }
    } else if (v_field_S [cur_x][cur_y] == 1 && v_field_E [cur_x][cur_y] == 1) {
      // Go S or E
      if (b) {
        next_x = cur_x;
        next_y = cur_y - 1;
      } else {
        next_x = cur_x + 1;
        next_y = cur_y;
      }
    } else if (v_field_S [cur_x][cur_y] == 1 && v_field_W [cur_x][cur_y] == 1) {
      // S or W
      if (b) {
        next_x = cur_x;
        next_y = cur_y - 1;
      } else {
        next_x = cur_x - 1;
        next_y = cur_y;
      }
    } else if (v_field_N [cur_x][cur_y] == 1) {
      // Go N
      next_x = cur_x;
      next_y = cur_y + 1;
    } else if (v_field_E [cur_x][cur_y] == 1) {
      // Go E
      next_x = cur_x + 1;
      next_y = cur_y;
    } else if (v_field_W [cur_x][cur_y] == 1) {
      // Go W
      next_x = cur_x - 1;
      next_y = cur_y;
    } else if (v_field_S [cur_x][cur_y] == 1) {
      // Go S
      next_x = cur_x;
      next_y = cur_y - 1;
    }

    // Fill TCL_index with next point
    x_TCL[TCL_index][id] = next_x;
    y_TCL[TCL_index][id] = next_y;
  }

  int CDAI (int other) {
    int i, j; // for-loop variables

    for (i = 0; i < TCL_LENGTH; i = i + 1) {
      for (j = 0; j < TCL_LENGTH; j = j + 1) {
        if (x_TCL[i][id] != -1 // -1 means no element at i in TCL
            && x_TCL[i][id] == x_TCL[j][other]
            && y_TCL[i][id] == y_TCL[j][other]) {
          // Index of the TIC in this node's TCL
          return i;
        }
      }
    }
    // No TIC
    return -1;
  }

  void ROUND () {
    int next_x, next_y;
    int TIC_index;
    int int_node; // intersecting node
    int i, j; // for-loop variable

    print_global_state();

    if (state[id] == INITS) {
      // Assume valid initial location,
      // i.e., on a lane and not approaching or crossing intersection

      // Create initial TCL
      COMPUTE_TCL();
      state[id] = OUTSIDE;
    }

    if (state[id] == OUTSIDE) {
      if (x[id] < 0 || x[id] >= X || y[id] < 0 || y[id] >= Y) {
        // Out of grid bound
        state[id] = FAR;
        done[id] = 1; // this node is done and ready to terminate
        return;
      }

      // Next point in TCL
      next_x = x_TCL[1][id];
      next_y = y_TCL[1][id];

      if (!EXISTS_ANY (n, x[n] == next_x && y[n] == next_y)) {
        // Next point is unoccupied

        if (MOVE_TO(next_x, next_y)) {
          // Move to next point
          x[id] = next_x;
          y[id] = next_y;
          UPDATE_TCL();

          for (i = 0; i < NUM_INTS_X; i = i + 1) {
            for (j = 0; j < NUM_INTS_Y; j = j + 1) {
              if ((x[id] == N_lanes[i] && y[id] == E_lanes[j] - 1) || // A
                  (y[id] == E_lanes[j] && x[id] == S_lanes[i] - 1) || // B
                  (y[id] == W_lanes[j] && x[id] == N_lanes[i] + 1) || // C
                  (x[id] == S_lanes[i] && y[id] == W_lanes[j] + 1)) { // D
                // Approaching intersection
                state[id] = APPROACH;
              }
            }
          }
        }
      }
    } else if (state[id] == APPROACH) {
      // Priority policy:
      // 1. Crossing nodes > approaching nodes (FCFS)
      // 2. Higher-id nodes > lower-id nodes

      FORALL_OTHER (n) {
        if ((state[n] == CROSS) || (state[n] == APPROACH && n > id)) {
          // Node n has higher priority
          // Get index of TIC in this node's TCL, if exists
          TIC_index = CDAI(n);

          if (TIC_index >= 0) {
            // TIC exists
            // Keep track of all TICs and corresponding nodes
            TIC[TIC_index] = 1;
            TIN[TIC_index] = n;
          }
        }
        // Not keep track of TICs of lower-priority nodes
      }

      state[id] = CROSS;
    } else if (state[id] == CROSS) {
      next_x = x_TCL[1][id];
      next_y = y_TCL[1][id];

      if (TIC[1] == 1) {
        // Next cell is TIC
        int_node = TIN[1];

        for (i = 0; i < TCL_LENGTH; i = i + 1) {
          if (x_TCL[i][int_node] == next_x && y_TCL[i][int_node] == next_y) {
            // The (higher-priority) intersecting node has not gone pass the TIC yet
            // Must wait
            return;
          }
        }
      }

      if (MOVE_TO(next_x, next_y)) {
        // Move to next point
        x[id] = next_x;
        y[id] = next_y;
        UPDATE_TCL();

        for (i = 0; i < NUM_INTS_X; i = i + 1) {
          for (j = 0; j < NUM_INTS_Y; j = j + 1) {
            if ((x[id] == N_lanes[i] - 1 && y[id] == E_lanes[j] - 1) || // next to A
                (y[id] == E_lanes[j] + 1 && x[id] == S_lanes[i] - 1) || // next to B
                (y[id] == W_lanes[j] - 1 && x[id] == N_lanes[i] + 1) || // next to C
                (x[id] == S_lanes[i] + 1 && y[id] == W_lanes[j] + 1)) { // next to D
              // Exiting intersection
              state[id] = OUTSIDE;
            }
          }
        }
      }
    }
  }

  // BELOW FUNCTIONS ARE CALLED BEFORE EACH ROUND
  // IN THE ORDER THEY APPEAR

  @ONCE_EVERY (10)
  void LOG_STATUS () {
    LOG(state[id], x[id], y[id]);
  }

  // Check safety property
  // Terminate this node if property is violated
  // IMP0RTANT NOTE:
  // Once any node terminated, the master process must kill all other nodes.
  @ONCE_EVERY (1)
  void NODE_ASSERT () {
    FORALL_OTHER (i) {
      if (true_state[i] != FAR) { // Not consider nodes that are out of grid boundary
        // Assert no collision
        LOCAL_ASSERT (true_x[i] != x[id] || true_y[i] != y[id]);
      }
    }
  }

  // Check if all nodes are done, i.e., state == FAR,
  // if so, terminate this node
  // IMPORTANT NOTE:
  // If this node terminates before it successfully broadcasts its "done" flag,
  // other nodes will continue indefinitely.
  // To handle this, have the master process kill all other nodes if any node terminated.
  @ONCE_EVERY (1)
  void CHECK_ALL_DONE () {
    if (!EXISTS_ANY (i, done[i] == 0)) {
      // Terminate this node
      EXIT;
    }
  }

}

//program has four nodes with ids 0, 1, 2, and 3
PROGRAM = uav (0) || uav (1) || uav (2) || uav (3);

//initial state
void INIT () 
{
  ATOMIC {
    FORALL_NODE(id) {
      state.id = INITS;
      ND(x.id); ND(y.id);
      ASSUME(0 <= x.id && x.id < X && 0 <= y.id && y.id < Y);
      ND(xf.id); ND(yf.id);
      ASSUME(0 <= xf.id && xf.id < X && 0 <= yf.id && yf.id < Y);
    }
  }

  FORALL_DISTINCT_NODE_PAIR (id1,id2) {
    ASSUME(x.id1 != x.id2 || y.id1 != y.id2);
  }
}

//the safety property checked at the beginning of each round
void SAFETY ()
{
  FORALL_DISTINCT_NODE_PAIR (id1,id2) {
    ASSERT(x.id1 != x.id2 || y.id1 != y.id2);
  }
}
