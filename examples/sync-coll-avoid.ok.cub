(***************
int Lock[N];
int State[N];
1. if (State[i] == 0) {
     NEXT_XY();
     State[i] := 1;
1. } else if (State[i] == 1) {
     if (forall j . j < i -> lock[j] = 0)
       State[i] = 2;
     else
       State[i] = 1;
1. } else if(State[i] == 2) {
     if (forall j . j > i -> lock[j] = 0)
       State[i] = 3;
     else
       State[i] = 2;
1. } else if(State[i] == 3) {
     if (MOVE_TO()) {
       State[i] = 0; Lock[i] = 0;
     }
   }
****************)

type xvals = XZero | XOne | XTwo | XThree
type yvals = YZero | YOne | YTwo | YThree
type round = CheckInit | Out | In
type trans = Zero | One | Two
type loc = L1
type state = S0 | S1 | S2 | S3
var XMAX : int
var YMAX : int
var Round : round
array InitOK[proc] : bool
array Trans[proc] : trans
array Loc[proc] : loc
array State[proc] : state
array LockX[proc] : int
array LockY[proc] : int
array LockXP[proc] : int
array LockYP[proc] : int
array X[proc] : int (* current X coordinate *)
array Y[proc] : int (* current Y coordinate *)
array XP[proc] : int (* next X coordinate *)
array YP[proc] : int (* next Y coordinate *)
array XF[proc] : int (* final X coordinate *)
array YF[proc] : int (* final Y coordinate *)

(* initial state *)
init (z) {
  0 < XMAX && 0 < YMAX && Round = CheckInit && 
    XMAX = 3 && YMAX = 3 &&
    InitOK[z] = False && Trans[z] = Zero && 
    Loc[z] = L1 && State[z] = S0 && 
    0 <= X[z] && X[z] <= XMAX && 0 <= Y[z] && Y[z] <= YMAX && 
    0 <= XF[z] && XF[z] <= XMAX && 0 <= YF[z] && YF[z] <= YMAX && 
    XP[z] = XMAX+1 && YP[z] = YMAX+1 &&
    LockX[z] = X[z] && LockY[z] = Y[z] &&
    LockXP[z] = XP[z] && LockYP[z] = YP[z]
}

(* error state *)
unsafe (x y) {
  Round = Out && State[x] = S3 && State[y] = S3
}

(* check the initial condition - no two nodes must be on the same XY
   coordinate initially or finally *)
transition check_init_0 (i)
requires { Round = CheckInit && InitOK[i] = False && 
    State[i] = S0 && Trans[i] = Zero && Loc[i] = L1 &&
    forall_other j. (State[j] = S0 && Trans[j] = Zero && Loc[j] = L1) &&
    forall_other j. (X[i] <> X[j] || Y[i] <> Y[j]) &&
    forall_other j. (XF[i] <> XF[j] || YF[i] <> YF[j]) }
{
  InitOK[i] := True;
}

(* if all nodes have successfully checked the initial condition, move
   to Round = Out *)
transition check_init_1 (i)
requires { Round = CheckInit && InitOK[i] = True &&
    State[i] = S0 && Trans[i] = Zero && Loc[i] = L1 &&
    forall_other j. (InitOK[j] = True && State[j] = S0 && Trans[j] = Zero && Loc[j] = L1) }
{
  Round := Out;
}

(* a node starts entering the round -- this only happens when Round is
   Out *)
transition enter_round_local (i)
requires { Round = Out }
{
  Trans[i] := One;
}

(* once all nodes have entered the round, Round becomes In *)
transition enter_round_global (i)
requires { Round = Out && Trans[i] = One && forall_other j. Trans[j] = One }
{
  Round := In;
}

(* when Round is In, any node can start executing its Round()
   function, but only if no other node is also executing its Round()
   function. *)
transition start_trans (i)
requires { Round = In && Trans[i] = One && forall_other j. Trans[j] <> Two }
{
  Trans[i] := Two;
  Loc[i] := L1;
}

(* remain in S0 if already at (XF,YF) *)
transition trans_S0_0 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S0 &&
         X[i] = XF[i] && Y[i] = YF[i] }
{
  State[i] := S0; Trans[i] := Zero; Loc[i] := L1;
}

(* go from S0 to S1 -- case X < XF *)
transition trans_S0_1 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S0  && X[i] < XF[i] }
{
  State[i] := S1; Trans[i] := Zero; Loc[i] := L1; XP[i] := X[i] + 1;
}

(* go from S0 to S1 -- case X > XF *)
transition trans_S0_2 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S0  && XF[i] < X[i] }
{
  State[i] := S1; Trans[i] := Zero; Loc[i] := L1; XP[i] := X[i] - 1;
}

(* go from S0 to S1 -- case X = XF && Y < YF *)
transition trans_S0_3 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S0  && X[i] = XF[i] && Y[i] < YF[i] }
{
  State[i] := S1; Trans[i] := Zero; Loc[i] := L1; YP[i] := Y[i] + 1;
}

(* go from S0 to S1 -- case X = XF && Y > YF *)
transition trans_S0_4 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S0  && X[i] = XF[i] && YF[i] < Y[i] }
{
  State[i] := S1; Trans[i] := Zero; Loc[i] := L1; YP[i] := Y[i] - 1;
}

(* go from S0 to S1 -- case X = XF && Y = YF *)
transition trans_S0_5 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S0  && X[i] = XF[i] && YF[i] = Y[i] }
{
  State[i] := S1; Trans[i] := Zero; Loc[i] := L1;
}

(* go from S1 to S2 if no lower-id node has the lock *)
transition trans_01 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S1 && 
    forall_other j. (i < j || LockX[j] <> XP[i] || LockY[j] <> YP[i]) }
{
  State[i] := S2; Trans[i] := Zero; Loc[i] := L1; LockXP[i] := XP[i]; LockYP[i] := YP[i];
}

(* remain in S1 if a lower id node has the lock *)
transition trans_02 (i)
requires { Round = In && Trans[i] = One && Loc[i] = L1 }
{
  State[j] := case
    | i < j && LockX[i] = XP[j] && LockY[i] = YP[j] && State[j] = S1 && 
      Trans[j] = Two && Loc[j] = L1 : S1
    | _ : State[j];
  Trans[j] := case
    | i < j && LockX[i] = XP[j] && LockY[i] = YP[j] && State[j] = S1 &&
      Trans[j] = Two && Loc[j] = L1 : Zero
    | _ : Trans[j];
  Loc[j] := case
    | i < j && LockX[i] = XP[j] && LockY[i] = YP[j] && State[j] = S1 &&
      Trans[j] = Two && Loc[j] = L1 : L1
    | _ : Loc[j];
}

(* move from S2 to S3 if no higher id node requested the lock *)
transition trans_03 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S2 && 
    forall_other j. (j < i || LockXP[j] <> XP[i] || LockYP[j] <> YP[i]) }
{
  State[i] := S3; Trans[i] := Zero; Loc[i] := L1;
}

(* remain in S2 if a higher id node has the lock *)
transition trans_04 (i)
requires { Round = In && Trans[i] = One && Loc[i] = L1 }
{
  State[j] := case
    | j < i && LockXP[i] = XP[j] && LockYP[i] = YP[j] && State[j] = S2 && 
      Trans[j] = Two && Loc[j] = L1 : S2
    | _ : State[j];
  Trans[j] := case
    | j < i && LockXP[i] = XP[j] && LockYP[i] = YP[j] && State[j] = S2 &&
      Trans[j] = Two && Loc[j] = L1 : Zero
    | _ : Trans[j];
  Loc[j] := case
    | j < i && LockXP[i] = XP[j] && LockYP[i] = YP[j] && State[j] = S2 &&
      Trans[j] = Two && Loc[j] = L1 : L1
    | _ : Loc[j];
}

(* go from S3 to S0 non-deterministically *)
transition trans_05 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S3 }
{
  State[i] := S0; Trans[i] := Zero; Loc[i] := L1;   
  X[i] := XP[i]; Y[i] := YP[i];
  LockX[i] := XP[i]; LockY[i] := YP[i];
  XP[i] := XMAX+1; YP[i] := YMAX+1;
  LockXP[i] := XMAX+1; LockYP[i] := YMAX+1;
}

(* stay in S3 non-deterministically *)
transition trans_06 (i)
requires { Round = In && Trans[i] = Two && Loc[i] = L1 && State[i] = S3 }
{
  State[i] := S3; Trans[i] := Zero; Loc[i] := L1;
}

(* If all nodes are in Zero and Round is In, this means that all nodes
   have executed their round function. In this case, Round becomes out
   and we repeat the whole process. *)
transition exit_round (i)
requires { Round = In && Trans[i] = Zero && forall_other j. Trans[j] = Zero }
{
  Round := Out;
}
